"""
Selective restoration for image-based redaction outputs.

This module provides the ImageRestorer class, which is responsible for
the "de-redaction" of text generated by an LLM that has processed a
redacted image's context.

Core Principle - Selective Restoration:
The key function of this class is to distinguish between placeholders that
correspond to actual, detected PII (from the mapping) and placeholders that
the LLM may have "hallucinated."

- If a placeholder (e.g., `[FACE_A]`) exists in the mapping, it is restored
  to a descriptive text format (e.g., `[Face detected at position (x,y)]`).
- If a placeholder (e.g., `[FACE_Z]`) does NOT exist in the mapping, it is
  left unchanged in the text.

This prevents the system from presenting LLM-generated fabrications as
verified facts, which is critical for trust and accuracy. This restoration
is purely text-based; it does not modify any images.
"""
import logging
import re
import time
from typing import Any, Dict, List, Tuple

from redactor.base.base_classes import BaseRestorer


class ImageRestorer(BaseRestorer):
    """
    Restores placeholders in LLM-generated text based on an image redaction map.

    This class implements selective restoration, only replacing placeholders that
    are present in the provided mapping. This mechanism is crucial for
    distinguishing between verified information from the original source and
    potentially hallucinated content from the LLM.

    Attributes:
        logger: A logger instance for logging events.
        restoration_template: A string template for formatting restored text.
        placeholder_pattern: A compiled regex pattern to find all valid placeholders.
    """

    def __init__(self,
                 restoration_template: str = "{placeholder} (Original: {original_text})"):
        """
        Initializes the ImageRestorer.

        Args:
            restoration_template (str): A template string for restoration.
                Note: Specific entity types may override this with their own
                hardcoded formats for clarity.
        """
        self.logger = logging.getLogger(__name__)
        self.restoration_template = restoration_template
        # Pattern to detect placeholders for faces, text, objects, vehicles, and devices
        self.placeholder_pattern = re.compile(
            r'\[(FACE|TEXT|OBJECT|VEHICLE|DEVICE)_[A-Z]\]'
        )
        self._reset_stats()
        self.logger.info("ImageRestorer initialized.")

    def _reset_stats(self):
        """Resets the internal statistics counters for a new session."""
        self._total_placeholders_found = 0
        self._restored_count = 0
        self._skipped_count = 0
        self._hallucinated_placeholders: List[str] = []
        self._restored_placeholders: List[str] = []
        self._start_time = 0.0

    def restore(self, text: str, mapping: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
        """
        Finds and restores placeholders in a text string based on a mapping.

        This is the main entry point for the restoration process. It iterates
        through all unique placeholders found in the text, restores them if they
        exist in the mapping, and collects detailed statistics on the process.

        Args:
            text (str): The input text from an LLM, potentially containing placeholders.
            mapping (Dict[str, Any]): A dictionary mapping placeholders to their
                original entity information.

        Returns:
            A tuple containing:
                - The restored text string.
                - A dictionary with detailed restoration statistics.
        """
        self._reset_stats()
        self._start_time = time.time()

        if not text:
            return "", self.get_restoration_stats()

        mapping = mapping or {}
        all_found = self.placeholder_pattern.findall(text)
        self._total_placeholders_found = len(all_found)
        unique_placeholders = self._find_placeholders(text)

        restored_text = text

        for placeholder in unique_placeholders:
            occurrences = restored_text.count(placeholder)
            if occurrences == 0:
                continue

            replacement = self._restore_placeholder(placeholder, mapping, occurrences)

            if replacement != placeholder:
                restored_text = restored_text.replace(placeholder, replacement)
                self._restored_count += occurrences
                if placeholder not in self._restored_placeholders:
                    self._restored_placeholders.append(placeholder)

        return restored_text, self.get_restoration_stats()

    def _find_placeholders(self, text: str) -> List[str]:
        """
        Uses regex to find all unique placeholders in the text.

        Args:
            text (str): The text to search for placeholders.

        Returns:
            A list of unique placeholder strings found in the text, sorted
            by length in descending order to prevent nested replacement issues.
        """
        if not text:
            return []
        # Use finditer to get match objects, then extract the full match (group 0)
        found_placeholders = [m.group(0) for m in self.placeholder_pattern.finditer(text)]
        # Sort by length descending to handle overlapping cases safely if any
        return sorted(list(set(found_placeholders)), key=len, reverse=True)


    def _restore_placeholder(self, placeholder: str, mapping: Dict[str, Any], occurrences: int) -> str:
        """
        Determines the replacement for a single placeholder.

        This helper checks if the placeholder is in the mapping. If so, it
        formats a replacement string based on the entity type. If not, it
        logs it as a hallucination. It also updates statistics for skipped items.

        Args:
            placeholder (str): The placeholder to restore.
            mapping (Dict[str, Any]): The map of placeholders to entities.
            occurrences (int): The number of times this placeholder appears.

        Returns:
            The replacement string, or the original placeholder if it's a
            hallucination or cannot be restored.
        """
        if placeholder not in mapping:
            self.logger.warning(
                f"Found hallucinated placeholder not in mapping: {placeholder}"
            )
            if placeholder not in self._hallucinated_placeholders:
                self._hallucinated_placeholders.append(placeholder)
            return placeholder

        entity_info = mapping[placeholder]

        if not isinstance(entity_info, dict) or ('type' not in entity_info and 'original_type' not in entity_info):
            self.logger.warning(
                f"Malformed mapping for placeholder {placeholder}. Skipping."
            )
            self._skipped_count += occurrences
            return placeholder

        entity_type = entity_info.get('type') or entity_info.get('original_type')
        replacement_str = None

        if entity_type == 'OCR_TEXT':
            original_text = entity_info.get('original_text')
            if original_text:
                replacement_str = original_text
            else:
                self.logger.warning(
                    f"Missing 'original_text' for OCR_TEXT placeholder {placeholder}. Skipping."
                )
        elif entity_type == 'FACE':
            bbox = entity_info.get('bbox')
            if bbox and isinstance(bbox, (list, tuple)) and len(bbox) == 4:
                replacement_str = f"[Face detected at position ({bbox[0]}, {bbox[1]})]"
            else:
                self.logger.warning(
                    f"Missing or malformed 'bbox' for FACE placeholder {placeholder}. Skipping."
                )
        elif entity_type in ('VEHICLE', 'DEVICE', 'OBJECT'):
            replacement_str = f"[{entity_type.capitalize()} detected]"
        else:
            self.logger.warning(
                f"Placeholder {placeholder} has unhandled type '{entity_type}'. Skipping."
            )

        if replacement_str is None:
            self._skipped_count += occurrences
            return placeholder

        return replacement_str

    def get_restoration_stats(self) -> Dict[str, Any]:
        """
        Compiles and returns the statistics for the last restoration operation.

        Returns:
            A dictionary containing detailed metrics about the restoration process.
        """
        restoration_time = (time.time() - self._start_time) if self._start_time > 0 else 0.0
        return {
            "total_placeholders_found": self._total_placeholders_found,
            "restored_count": self._restored_count,
            "skipped_count": self._skipped_count,
            "hallucinated_placeholders": sorted(self._hallucinated_placeholders),
            "restored_placeholders": sorted(self._restored_placeholders),
            "restoration_time": restoration_time,
        }
